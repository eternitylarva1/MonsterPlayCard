package EveryMonsterPlayCard.monstercards;

import EveryMonsterPlayCard.utils.Hpr;
import com.badlogic.gdx.Gdx;
import com.megacrit.cardcrawl.actions.AbstractGameAction;
import com.megacrit.cardcrawl.actions.common.DamageAction;
import com.megacrit.cardcrawl.actions.common.GainBlockAction;
import com.megacrit.cardcrawl.cards.AbstractCard;
import com.megacrit.cardcrawl.cards.CardGroup;
import com.megacrit.cardcrawl.cards.DamageInfo;
import com.megacrit.cardcrawl.characters.AbstractPlayer;
import com.megacrit.cardcrawl.core.Settings;
import com.megacrit.cardcrawl.dungeons.AbstractDungeon;
import com.megacrit.cardcrawl.helpers.CardLibrary;
import com.megacrit.cardcrawl.helpers.input.InputHelper;
import com.megacrit.cardcrawl.monsters.AbstractMonster;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * MonsterCardPlayer - 改进版怪物出牌系统
 * 怪物回合开始时自动出牌
 */
public class MonsterCardPlayer {

    // 关联的怪物
    public AbstractMonster monster;

    // 卡牌配置管理器
    private MonsterCardConfig cardConfig;

    // 独立牌库系统
    private CardGroup monsterDrawPile;                     // 怪物抽牌堆
    private CardGroup monsterDiscardPile;                  // 怪物弃牌堆

    // 当前显示的卡牌
    private AbstractCard displayedCard = null;            // 当前显示在头顶的卡牌
    private float cardDisplayTimer = 0.0f;                // 卡牌显示计时器

    // 出牌控制
    private boolean enabled = false;                       // 是否启用出牌系统
    private boolean hasPlayedCardThisTurn = false;         // 当前回合是否已出牌

    // 卡牌显示位置
    private static final float CARD_DISPLAY_HEIGHT = 80.0f * Settings.scale;
    private static final float CARD_HOVER_SCALE = 0.6f;
    private static final float CARD_NORMAL_SCALE = 0.4f;

    public MonsterCardPlayer(AbstractMonster monster) {
        this.monster = monster;
        this.cardConfig = MonsterCardConfig.getInstance();
        initializeCardSystem();
    }

    /**
     * 初始化怪物的牌库系统（基于统一卡牌池）
     */
    private void initializeCardSystem() {
        // 初始化牌库
        monsterDrawPile = new CardGroup(CardGroup.CardGroupType.DRAW_PILE);
        monsterDiscardPile = new CardGroup(CardGroup.CardGroupType.DISCARD_PILE);

        // 获取统一卡牌池
        ArrayList<AbstractCard> monsterCards = getUniversalCards();
        if (monsterCards.isEmpty()) {
            Hpr.info("警告：怪物 " + monster.name + " 没有可用的卡牌");
            return;
        }

        // 洗牌并初始化抽牌堆
        shuffleIntoDrawPile(monsterCards);

        Hpr.info("怪物CardPlayer初始化完成: " + monster.name + " ，牌库包含 " + monsterDrawPile.size() + " 张卡牌");
    }

    /**
     * 获取统一怪物卡牌池
     */
    private ArrayList<AbstractCard> getUniversalCards() {
        ArrayList<AbstractCard> cards = new ArrayList<>();

        // 直接从配置管理器获取统一卡牌池
        List<AbstractCard> configCards = cardConfig.getMonsterCardConfig(monster.id);
        if (configCards != null && !configCards.isEmpty()) {
            cards.addAll(configCards);
            Hpr.info("为怪物 " + monster.name + " 加载了统一卡牌池，包含 " + cards.size() + " 张卡牌");
        } else {
            Hpr.info("警告：怪物 " + monster.name + " 无法获取统一卡牌池");
        }

        return cards;
    }

    /**
     * 洗牌到抽牌堆
     */
    private void shuffleIntoDrawPile(ArrayList<AbstractCard> cards) {
        monsterDrawPile.clear();

        if (cards == null || cards.isEmpty()) {
            Hpr.info("警告：怪物 " + monster.name + " 没有可用的卡牌");
            return;
        }

        // 添加卡牌到抽牌堆
        for (AbstractCard card : cards) {
            if (card != null) {
                monsterDrawPile.addToBottom(card);
            }
        }

        // 洗牌
        ArrayList<AbstractCard> tempList = new ArrayList<>();
        tempList.addAll(monsterDrawPile.group);
        Collections.shuffle(tempList, AbstractDungeon.cardRandomRng.random);
        monsterDrawPile.group = tempList;

        Hpr.info("怪物 " + monster.name + " 洗牌完成，抽牌堆包含 " + monsterDrawPile.size() + " 张卡牌");
    }

    /**
     * 启用出牌系统
     */
    public void enable() {
        if (!enabled) {
            enabled = true;
            hasPlayedCardThisTurn = false;
            Hpr.info("怪物 " + monster.name + " 出牌系统已启用");
        }
    }

    /**
     * 禁用出牌系统
     */
    public void disable() {
        if (enabled) {
            enabled = false;
            displayedCard = null;
            cardDisplayTimer = 0.0f;
            Hpr.info("怪物 " + monster.name + " 出牌系统已禁用");
        }
    }

    /**
     * 怪物回合开始时调用（由补丁触发）
     */
    public void onTurnStart() {
        if (!enabled || monster == null) {
            return;
        }

        // 重置回合标记
        hasPlayedCardThisTurn = false;

        // 出牌（每个怪物回合出1张牌）
        playCardForTurn();

        Hpr.info("怪物 " + monster.name + " 回合开始，已出牌: " + hasPlayedCardThisTurn);
    }

    /**
     * 更新出牌逻辑（主要用于卡牌显示更新）
     */
    public void update() {
        if (!enabled || monster == null || AbstractDungeon.screen != AbstractDungeon.CurrentScreen.NONE) {
            return;
        }

        // 更新卡牌显示计时器
        if (cardDisplayTimer > 0.0f) {
            cardDisplayTimer -= Gdx.graphics.getDeltaTime();
            if (cardDisplayTimer <= 0.0f) {
                displayedCard = null;
            }
        }

        // 更新显示卡牌的位置
        updateCardDisplay();
    }

    /**
     * 为当前回合出牌
     */
    private void playCardForTurn() {
        if (hasPlayedCardThisTurn) {
            return; // 已经出过牌了
        }

        if (monsterDrawPile == null || monsterDrawPile.isEmpty()) {
            // 尝试从弃牌堆重新洗牌
            if (monsterDiscardPile != null && !monsterDiscardPile.isEmpty()) {
                shuffleDiscardToDraw();
            } else {
                Hpr.info("怪物 " + monster.name + " 牌库已空，无法出牌");
                return;
            }
        }

        // 从抽牌堆抽一张牌
        AbstractCard drawnCard = monsterDrawPile.getTopCard();
        if (drawnCard != null) {
            // 移除顶牌
            monsterDrawPile.removeTopCard();

            // 复制一张用于显示
            displayedCard = drawnCard.makeStatEquivalentCopy();

            // 设置显示计时器
            cardDisplayTimer = 3.0f; // 显示3秒

            // 执行卡牌效果（使用游戏原生Action系统）
            executeMonsterCard(drawnCard);

            // 标记本回合已出牌
            hasPlayedCardThisTurn = true;

            Hpr.info("怪物 " + monster.name + " 回合开始打出了: " + drawnCard.name);
        }
    }

    /**
     * 执行怪物的卡牌效果（使用游戏原生Action系统，模仿原版怪物）
     */
    private void executeMonsterCard(AbstractCard card) {
        if (card == null || monster == null) {
            return;
        }

        try {
            // 安全检查
            if (AbstractDungeon.getCurrRoom() == null ||
                AbstractDungeon.getCurrRoom().monsters == null ||
                AbstractDungeon.getCurrRoom().monsters.monsters.isEmpty()) {
                Hpr.info("怪物 " + monster.name + " 当前房间没有有效目标，跳过卡牌执行");
                return;
            }

            AbstractPlayer targetPlayer = AbstractDungeon.player;
            if (targetPlayer == null) {
                Hpr.info("怪物 " + monster.name + " 无法找到有效目标，跳过卡牌执行");
                return;
            }

            // 根据卡牌类型执行不同的Action（模仿原版怪物的takeTurn方法）
            if (card.type == AbstractCard.CardType.ATTACK) {
                // 攻击卡牌 - 造成伤害
                executeAttackCard(card, targetPlayer);
            } else if (card.type == AbstractCard.CardType.SKILL) {
                // 技能卡牌 - 获得格挡或其他效果
                executeSkillCard(card);
            } else if (card.type == AbstractCard.CardType.POWER) {
                // 能力卡牌 - 获得永久效果
                executePowerCard(card);
            }

            // 将用过的卡牌加入弃牌堆
            monsterDiscardPile.addToBottom(card.makeStatEquivalentCopy());

        } catch (Exception e) {
            Hpr.info("怪物 " + monster.name + " 执行卡牌时出错: " + e.getMessage());
        }
    }

    /**
     * 执行攻击卡牌（模仿原版怪物的DamageAction）
     */
    private void executeAttackCard(AbstractCard card, AbstractPlayer target) {
        if (card.damage > 0) {
            // 创建伤害信息（使用怪物的伤害信息系统）
            DamageInfo damageInfo = new DamageInfo(monster, card.damage, DamageInfo.DamageType.NORMAL);

            // 添加伤害Action（与原版怪物相同）
            AbstractDungeon.actionManager.addToBottom(
                new DamageAction(target, damageInfo, AbstractGameAction.AttackEffect.BLUNT_LIGHT)
            );
        }

        Hpr.info("怪物 " + monster.name + " 使用攻击卡牌 " + card.name + " 造成 " + card.damage + " 点伤害");
    }

    /**
     * 执行技能卡牌（模仿原版怪物的GainBlockAction等）
     */
    private void executeSkillCard(AbstractCard card) {
        if (card.block > 0) {
            // 获得格挡
            AbstractDungeon.actionManager.addToBottom(
                new GainBlockAction(monster, monster, card.block)
            );
        }

        Hpr.info("怪物 " + monster.name + " 使用技能卡牌 " + card.name + " 获得 " + card.block + " 点格挡");
    }

    /**
     * 执行能力卡牌（模仿原版怪物的ApplyPowerAction等）
     */
    private void executePowerCard(AbstractCard card) {
        // 这里可以扩展为应用各种power
        // 目前先处理力量提升
        if (card.name.contains("Rage") || card.name.contains("愤怒")) {
            AbstractDungeon.actionManager.addToBottom(
                new com.megacrit.cardcrawl.actions.common.ApplyPowerAction(
                    monster, monster,
                    new com.megacrit.cardcrawl.powers.StrengthPower(monster, 2), 2
                )
            );
        }

        Hpr.info("怪物 " + monster.name + " 使用能力卡牌 " + card.name);
    }

    /**
     * 从弃牌堆重新洗牌到抽牌堆
     */
    private void shuffleDiscardToDraw() {
        if (monsterDiscardPile == null || monsterDiscardPile.isEmpty()) {
            return;
        }

        int discardCount = monsterDiscardPile.size();

        monsterDrawPile.clear();
        ArrayList<AbstractCard> tempList = new ArrayList<>();
        tempList.addAll(monsterDiscardPile.group);
        Collections.shuffle(tempList, AbstractDungeon.cardRandomRng.random);
        monsterDrawPile.group = tempList;

        monsterDiscardPile.clear();

        Hpr.info("怪物 " + monster.name + " 从弃牌堆重新洗牌，将 " + discardCount + " 张牌重新加入抽牌堆");
    }

    /**
     * 更新卡牌显示
     */
    private void updateCardDisplay() {
        if (displayedCard != null && monster != null) {
            // 设置卡牌位置为怪物头顶
            float cardX = monster.drawX;
            float cardY = monster.drawY + monster.hb_h + CARD_DISPLAY_HEIGHT;

            displayedCard.current_x = cardX;
            displayedCard.current_y = cardY;
            displayedCard.target_x = cardX;
            displayedCard.target_y = cardY;

            // 根据鼠标hover调整缩放
            boolean isHovered = isCardHovered(displayedCard, cardX, cardY);
            float targetScale = isHovered ? CARD_HOVER_SCALE : CARD_NORMAL_SCALE;

            displayedCard.drawScale = targetScale;
            displayedCard.targetDrawScale = targetScale;

            // 更新卡牌状态
            displayedCard.update();
        }
    }

    /**
     * 手动检测卡牌是否被hover
     */
    private boolean isCardHovered(AbstractCard card, float cardX, float cardY) {
        if (card == null) {
            return false;
        }

        float mouseX = InputHelper.mX;
        float mouseY = InputHelper.mY;

        float cardWidth = card.hb.width;
        float cardHeight = card.hb.height;
        float cardLeft = cardX - cardWidth / 2.0f;
        float cardRight = cardX + cardWidth / 2.0f;
        float cardTop = cardY + cardHeight / 2.0f;
        float cardBottom = cardY - cardHeight / 2.0f;

        return mouseX >= cardLeft && mouseX <= cardRight &&
               mouseY >= cardBottom && mouseY <= cardTop;
    }

    /**
     * 渲染头顶卡牌
     */
    public void render(com.badlogic.gdx.graphics.g2d.SpriteBatch sb) {
        if (displayedCard != null) {
            displayedCard.render(sb);
        }
    }

    /**
     * 检查是否启用
     */
    public boolean isEnabled() {
        return enabled;
    }

    /**
     * 获取抽牌堆大小
     */
    public int getDrawPileSize() {
        return monsterDrawPile != null ? monsterDrawPile.size() : 0;
    }

    /**
     * 获取弃牌堆大小
     */
    public int getDiscardPileSize() {
        return monsterDiscardPile != null ? monsterDiscardPile.size() : 0;
    }

    /**
     * 重置系统（用于重置战斗状态）
     */
/**     * 手动添加卡牌到抽牌堆（用于测试）     */    public void addCardToDrawPile(AbstractCard card) {        if (card != null && monsterDrawPile != null) {            AbstractCard cardCopy = card.makeStatEquivalentCopy();            cardCopy.color = AbstractCard.CardColor.COLORLESS;            cardCopy.freeToPlayOnce = true;            cardCopy.cost = 0;            cardCopy.costForTurn = 0;            monsterDrawPile.addToBottom(cardCopy);            Hpr.info("为怪物 " + monster.name + " 添加了卡牌到抽牌堆: " + cardCopy.name);        }    }
        Hpr.info("怪物 " + monster.name + " CardPlayer系统已重置");
    }
}
