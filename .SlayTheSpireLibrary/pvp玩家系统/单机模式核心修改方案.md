# PVP in the Spire - å•æœºæ¨¡å¼æ ¸å¿ƒä¿®æ”¹æ–¹æ¡ˆ

## æ¦‚è¿°

æœ¬æ–‡æ¡£æå‡ºäº†å°†PVP in the Spireæ¨¡ç»„æ”¹é€ ä¸ºå•æœºæ¸¸ç©æ¨¡å¼çš„æ ¸å¿ƒä¿®æ”¹æ–¹æ¡ˆã€‚å•æœºæ¨¡å¼å°†ä¿ç•™å®Œæ•´çš„æˆ˜æ–—ç³»ç»Ÿå’Œæ•Œæ–¹ç©å®¶æ¸²æŸ“ï¼Œé€šè¿‡æœ¬åœ°äº‹ä»¶æ¨¡æ‹Ÿæ›¿ä»£ç½‘ç»œé€šä¿¡ï¼Œå®ç°è‡ªåŠ¨åŒ–æˆ˜æ–—ä½“éªŒã€‚

## ä¸€ã€æ€»ä½“æ¶æ„

### 1.1 æ ¸å¿ƒæ€è·¯
- **ä¿ç•™æ¸²æŸ“ç³»ç»Ÿ**ï¼šå®Œæ•´çš„æ•Œæ–¹ç©å®¶æ˜¾ç¤ºï¼ˆæ‰‹ç‰Œã€èƒ½é‡ã€é—ç‰©ã€å§¿æ€ç­‰ï¼‰
- **æœ¬åœ°äº‹ä»¶å¾ªç¯**ï¼šå°†ç½‘ç»œå‘é€æ›¿æ¢ä¸ºæœ¬åœ°äº‹ä»¶åˆ†å‘
- **è‡ªåŠ¨æ“ä½œæµç¨‹**ï¼šPlayerMonsterè‡ªåŠ¨æ‰§è¡Œå›åˆã€æŠ½ç‰Œã€å‡ºç‰Œç­‰
- **äº‹ä»¶é©±åŠ¨æ¶æ„**ï¼šé€šè¿‡äº‹ä»¶æ¨¡æ‹Ÿæ‰€æœ‰æˆ˜æ–—äº¤äº’

### 1.2 æ¶æ„å…³ç³»
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           å•æœºæ¨¡å¼æ¶æ„                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ è‡ªåŠ¨åŒ–ç®¡ç†å™¨ â”‚â”€â”€â”€â–¶â”‚ PlayerMonster â”‚  â”‚
â”‚  â”‚(å›åˆ/æŠ½ç‰Œ/   â”‚    â”‚  (æ•Œæ–¹ç©å®¶)   â”‚  â”‚
â”‚  â”‚  å‡ºç‰Œæ§åˆ¶)   â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚         â”‚
â”‚           â”‚                   â–¼         â”‚
â”‚           â”‚          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚           â”‚          â”‚ æ¸²æŸ“æ˜¾ç¤ºç³»ç»Ÿ  â”‚  â”‚
â”‚           â”‚          â”‚(BattleUIç­‰)   â”‚  â”‚
â”‚           â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚           â”‚                               â”‚
â”‚           â–¼                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚        æœ¬åœ°äº‹ä»¶æ€»çº¿                   â”‚ â”‚
â”‚  â”‚     (æ›¿ä»£ç½‘ç»œé€šä¿¡)                   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## äºŒã€ç½‘ç»œå±‚æœ¬åœ°åŒ–

### 2.1 é…ç½®ç³»ç»Ÿ

#### æ–°å¢ SinglePlayerConfig.java
```java
package pvp_in_the_spire.config;

public class SinglePlayerConfig {
    // å•æœºæ¨¡å¼æ€»å¼€å…³
    public static boolean SINGLE_PLAYER_MODE = true;

    // æ˜¯å¦å¯ç”¨è‡ªåŠ¨æˆ˜æ–—
    public static boolean AUTO_BATTLE = true;

    // è‡ªåŠ¨å‡ºç‰Œå»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰
    public static int AUTO_PLAY_DELAY = 800;

    // è‡ªåŠ¨æŠ½ç‰Œå»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰
    public static int AUTO_DRAW_DELAY = 500;

    // æ˜¯å¦æ˜¾ç¤ºæ“ä½œæ—¥å¿—
    public static boolean SHOW_OPERATION_LOG = true;

    // æ˜¯å¦è·³è¿‡AIåŠ¨ç”»æ•ˆæœ
    public static boolean SKIP_ANIMATIONS = false;
}
```

### 2.2 å…¨å±€å¼€å…³ä¿®æ”¹

#### ä¿®æ”¹ SocketServer.java
```java
// åœ¨SocketServer.javaé¡¶éƒ¨
public class SocketServer {
    // å•æœºæ¨¡å¼å¼€å…³
    public static boolean SINGLE_PLAYER_MODE = SinglePlayerConfig.SINGLE_PLAYER_MODE;
    public static boolean AUTO_BATTLE = SinglePlayerConfig.AUTO_BATTLE;

    // ä¿ç•™åŸæœ‰ç½‘ç»œç›¸å…³
    public static boolean USE_NETWORK = false;  // å•æœºæ¨¡å¼å…³é—­ç½‘ç»œ

    // æœ¬åœ°äº‹ä»¶æ€»çº¿
    public static LocalEventBus eventBus = new LocalEventBus();
}
```

### 2.3 æœ¬åœ°äº‹ä»¶æ€»çº¿

#### æ–°å¢ LocalEventBus.java
```java
package pvp_in_the_spire.network;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.function.Consumer;

public class LocalEventBus {
    // äº‹ä»¶ç±»å‹åˆ°å¤„ç†å™¨çš„æ˜ å°„
    private HashMap<Class<?>, ArrayList<Consumer<?>>> handlers;

    // äº‹ä»¶é˜Ÿåˆ—ï¼ˆç”¨äºå¼‚æ­¥å¤„ç†ï¼‰
    private ArrayList<Object> eventQueue;

    public LocalEventBus() {
        handlers = new HashMap<>();
        eventQueue = new ArrayList<>();
    }

    // æ³¨å†Œäº‹ä»¶å¤„ç†å™¨
    public <T> void registerEvent(Class<T> eventType, Consumer<T> handler) {
        handlers.computeIfAbsent(eventType, k -> new ArrayList<>())
                .add((Consumer<?>) handler);
    }

    // å‘é€äº‹ä»¶ï¼ˆåŒæ­¥å¤„ç†ï¼‰
    public <T> void sendEvent(T event) {
        processEvent(event);
    }

    // å‘é€äº‹ä»¶ï¼ˆå¼‚æ­¥å¤„ç†ï¼‰
    public <T> void sendEventAsync(T event) {
        eventQueue.add(event);
        // å¼‚æ­¥å¤„ç†äº‹ä»¶é˜Ÿåˆ—
        processEventQueue();
    }

    // å¤„ç†å•ä¸ªäº‹ä»¶
    @SuppressWarnings("unchecked")
    private <T> void processEvent(T event) {
        Class<?> eventType = event.getClass();
        ArrayList<Consumer<?>> handlerList = handlers.get(eventType);

        if (handlerList != null) {
            for (Consumer<?> handler : handlerList) {
                try {
                    ((Consumer<T>) handler).accept(event);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }

    // å¤„ç†äº‹ä»¶é˜Ÿåˆ—
    private void processEventQueue() {
        synchronized (eventQueue) {
            while (!eventQueue.isEmpty()) {
                Object event = eventQueue.remove(0);
                processEvent(event);
            }
        }
    }

    // æ¸…ç©ºé˜Ÿåˆ—
    public void clearQueue() {
        synchronized (eventQueue) {
            eventQueue.clear();
        }
    }
}
```

## ä¸‰ã€äº‹ä»¶ç³»ç»Ÿé€‚é…

### 3.1 Communication.javaæœ¬åœ°åŒ–

#### ä¿®æ”¹ Communication.java
```java
// åœ¨Communication.javaä¸­æ·»åŠ æœ¬åœ°å¤„ç†æ–¹æ³•
public class Communication {

    // æœ¬åœ°å‘é€äº‹ä»¶ï¼ˆæ›¿ä»£ç½‘ç»œå‘é€ï¼‰
    public static void sendEventLocal(BaseEvent event) {
        if (SinglePlayerConfig.SHOW_OPERATION_LOG) {
            System.out.println("[LOCAL] Sending event: " + event.eventId);
        }
        SocketServer.eventBus.sendEvent(event);
    }

    // é‡å†™advanceSendEventï¼Œæ”¯æŒæœ¬åœ°æ¨¡å¼
    public static void advanceSendEvent(BaseEvent event, int playerTag) {
        if (SinglePlayerConfig.SINGLE_PLAYER_MODE) {
            // æœ¬åœ°æ¨¡å¼ï¼šç›´æ¥å¤„ç†äº‹ä»¶
            handleEventLocally(event);
        } else {
            // ç½‘ç»œæ¨¡å¼ï¼šä½¿ç”¨åŸé€»è¾‘
            advanceSendEventNetwork(event, playerTag);
        }
    }

    // æœ¬åœ°äº‹ä»¶å¤„ç†
    private static void handleEventLocally(BaseEvent event) {
        try {
            // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿï¼ˆå¯é€‰ï¼‰
            if (!SinglePlayerConfig.SKIP_ANIMATIONS) {
                Thread.sleep(100);
            }

            // ç›´æ¥è§¦å‘äº‹ä»¶å¤„ç†å™¨
            SocketServer.eventBus.sendEvent(event);

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    // ä¿ç•™åŸæœ‰ç½‘ç»œå‘é€æ–¹æ³•
    private static void advanceSendEventNetwork(BaseEvent event, int playerTag) {
        // ... åŸæœ‰çš„ç½‘ç»œå‘é€é€»è¾‘ ...
    }
}
```

### 3.2 æœ¬åœ°äº‹ä»¶å¤„ç†å™¨

#### æ–°å¢ LocalEventHandler.java
```java
package pvp_in_the_spire.network;

import pvp_in_the_spire.actions.FightProtocol;
import pvp_in_the_spire.events.*;
import pvp_in_the_spire.patches.CardShowPatch.*;
import pvp_in_the_spire.character.PlayerMonster;
import pvp_in_the_spire.GlobalManager;

public class LocalEventHandler {

    // åˆå§‹åŒ–æ‰€æœ‰æœ¬åœ°äº‹ä»¶å¤„ç†å™¨
    public static void initLocalHandlers() {
        SocketServer.eventBus.registerEvent(UseCardEvent.class, LocalEventHandler::handleUseCard);
        SocketServer.eventBus.registerEvent(CardInfoEvent.class, LocalEventHandler::handleCardInfo);
        SocketServer.eventBus.registerEvent(UpdateHandCardEvent.class, LocalEventHandler::handleHandUpdate);
        SocketServer.eventBus.registerEvent(DrawCardUpdateEvent.class, LocalEventHandler::handleDrawUpdate);
        SocketServer.eventBus.registerEvent(EnergyUpdateEvent.class, LocalEventHandler::handleEnergyUpdate);
        SocketServer.eventBus.registerEvent(ApplyPowerEvent.class, LocalEventHandler::handlePowerApply);
        // æ³¨å†Œæ›´å¤šäº‹ä»¶...

        if (SinglePlayerConfig.SHOW_OPERATION_LOG) {
            System.out.println("[LOCAL] Event handlers initialized");
        }
    }

    // å¤„ç†ä½¿ç”¨å¡ç‰Œäº‹ä»¶
    private static void handleUseCard(UseCardEvent event) {
        if (SinglePlayerConfig.SHOW_OPERATION_LOG) {
            System.out.println("[LOCAL] Processing card use: " + event.cardCode);
        }

        // æŸ¥æ‰¾AIç©å®¶å¹¶è§¦å‘è‡ªåŠ¨æ“ä½œ
        PlayerMonster aiPlayer = findAIPlayer();
        if (aiPlayer != null && aiPlayer.autoPlayManager != null) {
            aiPlayer.autoPlayManager.onCardPlayed(event.cardCode);
        }
    }

    // å¤„ç†å¡ç‰Œä¿¡æ¯äº‹ä»¶
    private static void handleCardInfo(CardInfoEvent event) {
        if (SinglePlayerConfig.SHOW_OPERATION_LOG) {
            System.out.println("[LOCAL] Processing card info: " + event.card.cardID);
        }
        // å¡ç‰Œä¿¡æ¯å·²åœ¨è§£ç æ—¶å¤„ç†
    }

    // å¤„ç†æ‰‹ç‰Œæ›´æ–°äº‹ä»¶
    private static void handleHandUpdate(UpdateHandCardEvent event) {
        if (SinglePlayerConfig.SHOW_OPERATION_LOG) {
            System.out.println("[LOCAL] Hand updated, cards: " + event.cardIdList.size());
        }

        PlayerMonster aiPlayer = findAIPlayer();
        if (aiPlayer != null && aiPlayer.autoPlayManager != null) {
            aiPlayer.autoPlayManager.onHandUpdated(event.cardIdList);
        }
    }

    // å¤„ç†æŠ½ç‰Œæ›´æ–°äº‹ä»¶
    private static void handleDrawUpdate(DrawCardUpdateEvent event) {
        if (SinglePlayerConfig.SHOW_OPERATION_LOG) {
            System.out.println("[LOCAL] Draw pile updated, next cards: " + event.cardIdList.size());
        }
        // æ›´æ–°æŠ½ç‰Œå †æ˜¾ç¤º
    }

    // å¤„ç†èƒ½é‡æ›´æ–°äº‹ä»¶
    private static void handleEnergyUpdate(EnergyUpdateEvent event) {
        PlayerMonster aiPlayer = findAIPlayer();
        if (aiPlayer != null && aiPlayer.autoPlayManager != null) {
            aiPlayer.autoPlayManager.onEnergyUpdated(event.currentEnergy);
        }
    }

    // å¤„ç†Buffåº”ç”¨äº‹ä»¶
    private static void handlePowerApply(ApplyPowerEvent event) {
        if (SinglePlayerConfig.SHOW_OPERATION_LOG) {
            System.out.println("[LOCAL] Power applied: " + event.powerId + " x" + event.amount);
        }
    }

    // æŸ¥æ‰¾AIç©å®¶ï¼ˆæ•Œæ–¹ç©å®¶ï¼‰
    private static PlayerMonster findAIPlayer() {
        // ä»GlobalManagerä¸­æŸ¥æ‰¾ç¬¬ä¸€ä¸ªæ•Œæ–¹ç©å®¶
        return GlobalManager.getBattleInfo().getFirstEnemyPlayer();
    }
}
```

## å››ã€è‡ªåŠ¨åŒ–ç®¡ç†å™¨

### 4.1 è‡ªåŠ¨æ“ä½œç®¡ç†å™¨

#### æ–°å¢ AutoPlayManager.java
```java
package pvp_in_the_spire.battle;

import com.megacrit.cardcrawl.cards.AbstractCard;
import com.megacrit.cardcrawl.dungeons.AbstractDungeon;
import pvp_in_the_spire.character.PlayerMonster;
import pvp_in_the_spire.patches.CardShowPatch.CardRecorder;
import pvp_in_the_spire.player_management.PlayerCardManager;

import java.util.ArrayList;
import java.util.Random;

public class AutoPlayManager {
    private PlayerMonster player;
    private Random random;
    private boolean isProcessing = false;

    // å½“å‰æ‰‹ç‰Œ
    private ArrayList<Integer> currentHand;
    private int currentEnergy = 3;

    public AutoPlayManager(PlayerMonster player) {
        this.player = player;
        this.random = new Random();
        this.currentHand = new ArrayList<>();
    }

    // è‡ªåŠ¨æ‰§è¡Œå›åˆ
    public void executeTurn() {
        if (isProcessing || !SinglePlayerConfig.AUTO_BATTLE) {
            return;
        }

        isProcessing = true;

        new Thread(() -> {
            try {
                // å›åˆå¼€å§‹
                Thread.sleep(500);
                onTurnStart();

                // è‡ªåŠ¨å‡ºç‰Œå¾ªç¯
                playCardsInTurn();

                // å›åˆç»“æŸ
                Thread.sleep(500);
                onTurnEnd();

            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                isProcessing = false;
            }
        }).start();
    }

    // å›åˆå¼€å§‹å¤„ç†
    private void onTurnStart() {
        if (SinglePlayerConfig.SHOW_OPERATION_LOG) {
            System.out.println("[AUTO] Turn " + player.idTurn + " started");
        }

        // é‡ç½®èƒ½é‡
        setCurrentEnergy(3);

        // æŠ½ç‰Œ
        drawCards(5);

        // åº”ç”¨å›åˆå¼€å§‹æ•ˆæœ
        player.applyStartOfTurnPowers();
    }

    // å‡ºç‰Œå¾ªç¯
    private void playCardsInTurn() {
        int safetyCounter = 0;  // é˜²æ­¢æ— é™å¾ªç¯

        while (currentEnergy > 0 && !currentHand.isEmpty() && safetyCounter < 20) {
            safetyCounter++;

            // é€‰æ‹©è¦å‡ºçš„ç‰Œ
            Integer selectedCardId = selectCardToPlay();

            if (selectedCardId != null) {
                playCard(selectedCardId);
                // å‡ºç‰Œé—´éš”
                Thread.sleep(SinglePlayerConfig.AUTO_PLAY_DELAY);
            } else {
                break;  // æ²¡æœ‰å¯å‡ºçš„ç‰Œ
            }
        }
    }

    // é€‰æ‹©è¦å‡ºçš„ç‰Œï¼ˆç®€å•éšæœºç­–ç•¥ï¼‰
    private Integer selectCardToPlay() {
        if (currentHand.isEmpty()) {
            return null;
        }

        // è·å–å¯å‡ºçš„ç‰Œï¼ˆæœ‰è¶³å¤Ÿèƒ½é‡ï¼‰
        ArrayList<Integer> playableCards = new ArrayList<>();
        for (Integer cardId : currentHand) {
            AbstractCard card = getCardById(cardId);
            if (card != null && card.cost <= currentEnergy) {
                playableCards.add(cardId);
            }
        }

        if (playableCards.isEmpty()) {
            return null;
        }

        // éšæœºé€‰æ‹©ä¸€å¼ ç‰Œ
        return playableCards.get(random.nextInt(playableCards.size()));
    }

    // å‡ºç‰Œ
    private void playCard(Integer cardId) {
        AbstractCard card = getCardById(cardId);
        if (card == null) {
            return;
        }

        if (SinglePlayerConfig.SHOW_OPERATION_LOG) {
            System.out.println("[AUTO] Playing card: " + card.name + " (Cost: " + card.cost + ")");
        }

        // æ¶ˆè€—èƒ½é‡
        currentEnergy -= card.cost;

        // ä»æ‰‹ç‰Œç§»é™¤
        currentHand.remove(cardId);

        // æ¨¡æ‹Ÿå‡ºç‰Œæ•ˆæœ
        simulateCardEffect(card);

        // å‘é€å‡ºç‰Œäº‹ä»¶
        sendPlayCardEvent(card);
    }

    // æ¨¡æ‹Ÿå¡ç‰Œæ•ˆæœ
    private void simulateCardEffect(AbstractCard card) {
        switch (card.type) {
            case ATTACK:
                simulateAttack(card);
                break;
            case SKILL:
                simulateSkill(card);
                break;
            case POWER:
                simulatePower(card);
                break;
        }
    }

    private void simulateAttack(AbstractCard card) {
        int damage = card.baseDamage;
        // æ”»å‡»ç©å®¶
        AbstractDungeon.player.damage(
            new com.megacrit.cardcrawl.cards.DamageInfo(player, damage)
        );
    }

    private void simulateSkill(AbstractCard card) {
        int block = card.baseBlock;
        // ç»™è‡ªå·±åŠ æ ¼æŒ¡
        player.addBlock(block);
    }

    private void simulatePower(AbstractCard card) {
        // TODO: æ ¹æ®å…·ä½“èƒ½åŠ›å®ç°
        if (SinglePlayerConfig.SHOW_OPERATION_LOG) {
            System.out.println("[AUTO] Power activated: " + card.name);
        }
    }

    // å›åˆç»“æŸå¤„ç†
    private void onTurnEnd() {
        if (SinglePlayerConfig.SHOW_OPERATION_LOG) {
            System.out.println("[AUTO] Turn ended");
        }

        player.endOfTurnTrigger();
    }

    // æŠ½ç‰Œ
    private void drawCards(int num) {
        // TODO: ä»æŠ½ç‰Œå †æŠ½å–
        if (SinglePlayerConfig.SHOW_OPERATION_LOG) {
            System.out.println("[AUTO] Drawing " + num + " cards");
        }

        // æ¨¡æ‹ŸæŠ½åˆ°çš„ç‰Œï¼ˆå®é™…åº”è¯¥ä»æŠ½ç‰Œå †è·å–ï¼‰
        // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥å®ç°å®Œæ•´çš„æŠ½ç‰Œé€»è¾‘
    }

    // äº‹ä»¶å¤„ç†å™¨

    public void onCardPlayed(int cardCode) {
        // å¤„ç†å¯¹æ–¹å‡ºç‰Œäº‹ä»¶
        if (SinglePlayerConfig.SHOW_OPERATION_LOG) {
            System.out.println("[AUTO] Opponent played card: " + cardCode);
        }
    }

    public void onHandUpdated(ArrayList<Integer> newHand) {
        this.currentHand = new ArrayList<>(newHand);
        if (SinglePlayerConfig.SHOW_OPERATION_LOG) {
            System.out.println("[AUTO] Hand updated: " + currentHand.size() + " cards");
        }
    }

    public void onEnergyUpdated(int newEnergy) {
        this.currentEnergy = newEnergy;
        if (SinglePlayerConfig.SHOW_OPERATION_LOG) {
            System.out.println("[AUTO] Energy updated: " + currentEnergy);
        }
    }

    // è¾…åŠ©æ–¹æ³•

    private AbstractCard getCardById(int cardId) {
        PlayerCardManager cardManager = player.playerCardManager;
        return cardManager.getCard(cardId);
    }

    private void setCurrentEnergy(int energy) {
        this.currentEnergy = energy;
        player.battleCardPanel.setEnergy(energy);
    }

    private void sendPlayCardEvent(AbstractCard card) {
        // å‘é€å‡ºç‰Œäº‹ä»¶
        // è¿™é‡Œåº”è¯¥ä½¿ç”¨å®é™…çš„é€šä¿¡ç³»ç»Ÿ
        if (!SinglePlayerConfig.SINGLE_PLAYER_MODE) {
            // ç½‘ç»œæ¨¡å¼
            // UseCardSend.useCardEncode(streamHandle, card);
        } else {
            // æœ¬åœ°æ¨¡å¼ - å·²åœ¨simulateCardEffectä¸­å¤„ç†
        }
    }
}
```

## äº”ã€PlayerMonsteræ”¹é€ 

### 5.1 å¢å¼ºPlayerMonster

#### ä¿®æ”¹ PlayerMonster.java
```java
// åœ¨PlayerMonster.javaä¸­æ·»åŠ è‡ªåŠ¨åŒ–æ”¯æŒ
public class PlayerMonster extends AbstractMonster {
    // åŸæœ‰å­—æ®µ...

    // è‡ªåŠ¨åŒ–ç›¸å…³
    public AutoPlayManager autoPlayManager;
    public boolean isAutoPlay = false;  // æ˜¯å¦å¯ç”¨è‡ªåŠ¨æ“ä½œ

    // æ„é€ å‡½æ•°å¢å¼º
    public PlayerMonster(String name, boolean pauseFlag, float x, float y,
                        int playerTag, boolean sameTeam,
                        PlayerCardManager cardManager,
                        boolean isAutoPlay) {  // æ–°å¢è‡ªåŠ¨æ“ä½œæ ‡è®°

        // åŸæœ‰åˆå§‹åŒ–...
        this.isAutoPlay = isAutoPlay;

        // å¦‚æœå¯ç”¨è‡ªåŠ¨æ“ä½œï¼Œåˆå§‹åŒ–ç®¡ç†å™¨
        if (isAutoPlay) {
            this.autoPlayManager = new AutoPlayManager(this);
        }
    }

    // é‡å†™takeTurnï¼Œæ·»åŠ è‡ªåŠ¨æ‰§è¡Œ
    @Override
    public void takeTurn() {
        if (this.pauseFlag) {
            System.out.printf("%d take turn\n", playerTag);
            AbstractDungeon.actionManager.addToBottom(
                new MultiPauseAction()
            );
        }

        // å¦‚æœå¯ç”¨è‡ªåŠ¨æ“ä½œï¼Œè‡ªåŠ¨æ‰§è¡Œå›åˆ
        if (this.isAutoPlay && this.autoPlayManager != null) {
            // å»¶è¿Ÿä¸€ç‚¹æ—¶é—´ï¼Œè®©ç©å®¶çœ‹åˆ°AIå¼€å§‹å›åˆ
            new Thread(() -> {
                try {
                    Thread.sleep(800);
                    this.autoPlayManager.executeTurn();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        }
    }

    // è‡ªåŠ¨æŠ½ç‰Œæ–¹æ³•
    public void autoDrawCards(int cardNum) {
        if (this.isAutoPlay && this.autoPlayManager != null) {
            this.autoPlayManager.onHandUpdated(/* è·å–å½“å‰æ‰‹ç‰Œ */);
        }
    }

    // è‡ªåŠ¨ç»“æŸå›åˆ
    public void autoEndTurn() {
        if (this.isAutoPlay) {
            this.endOfTurnTrigger();
        }
    }

    // è·å–è‡ªåŠ¨æ“ä½œçŠ¶æ€
    public boolean isAutoPlaying() {
        return this.isAutoPlay && this.autoPlayManager != null &&
               this.autoPlayManager.isProcessing;
    }
}
```

### 5.2 æˆ˜æ–—åˆå§‹åŒ–é€‚é…

#### ä¿®æ”¹æˆ˜æ–—åˆ›å»ºé€»è¾‘
```java
// åœ¨åˆ›å»ºæ•Œæ–¹ç©å®¶çš„åœ°æ–¹
public PlayerMonster createAutoPlayer(int playerTag, boolean sameTeam) {
    // åˆ›å»ºè‡ªåŠ¨æ“ä½œç©å®¶
    PlayerMonster autoPlayer = new PlayerMonster(
        "Auto Player",     // åå­—
        false,             // ä¸æ˜¯æš‚åœæ ‡å¿—
        x, y,              // ä½ç½®
        playerTag,
        sameTeam,
        cardManager,
        true               // æ ‡è®°ä¸ºè‡ªåŠ¨æ“ä½œ
    );

    return autoPlayer;
}
```

## å…­ã€åè®®å¤„ç†æœ¬åœ°åŒ–

### 6.1 FightProtocol.javaä¿®æ”¹

#### ä¿®æ”¹ FightProtocol.java
```java
public class FightProtocol extends AbstractActionProtocol {

    // æœ¬åœ°æ¨¡å¼æ¶ˆæ¯å¤„ç†
    public boolean readDataLocal(DataInputStream stream) {
        try {
            int tempData = stream.readInt();

            if (SinglePlayerConfig.SINGLE_PLAYER_MODE) {
                // æœ¬åœ°æ¨¡å¼ï¼šç›´æ¥å¤„ç†æ¶ˆæ¯
                return handleLocalMessage(tempData, stream);
            } else {
                // ç½‘ç»œæ¨¡å¼ï¼šä½¿ç”¨åŸé€»è¾‘
                return handleNetworkMessage(tempData, stream);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return false;
    }

    // å¤„ç†æœ¬åœ°æ¶ˆæ¯
    private boolean handleLocalMessage(int tempData, DataInputStream stream) {
        switch (tempData) {
            case USE_CARD:
                // ç«‹å³æ˜¾ç¤ºå¡ç‰Œ
                UseCardSend.useCardDecode(stream);
                return true;

            case UPDATE_HAND_CARD:
                // æ›´æ–°æ‰‹ç‰Œæ˜¾ç¤º
                HandCardSend.handCardDecode(stream);
                return true;

            case DRAWING_CARD_UPDATE:
                // æ›´æ–°æŠ½ç‰Œå †æ˜¾ç¤º
                DrawPileSender.drawCardDecode(stream);
                return true;

            case ENERGY_UPDATE:
                // æ›´æ–°èƒ½é‡æ˜¾ç¤º
                ControlMoster.energyChangeDecode(stream);
                return true;

            case APPLY_POWER:
                // åº”ç”¨Buff
                ActionNetworkPatches.applyPowerDecode(stream);
                return true;

            // ... å…¶ä»–æ¶ˆæ¯ç±»å‹

            default:
                return false;
        }
    }

    // ä¿ç•™åŸæœ‰ç½‘ç»œæ¶ˆæ¯å¤„ç†
    private boolean handleNetworkMessage(int tempData, DataInputStream stream) {
        // åŸæœ‰çš„æ¶ˆæ¯å¤„ç†é€»è¾‘...
        return false;
    }
}
```

## ä¸ƒã€åˆå§‹åŒ–å’Œå¯åŠ¨

### 7.1 å¯åŠ¨åˆå§‹åŒ–

#### ä¿®æ”¹ PvPInTheSpireMod.java (ä¸»å…¥å£)
```java
// åœ¨ä¸»ç±»çš„åˆå§‹åŒ–æ–¹æ³•ä¸­æ·»åŠ 
public class PvPInTheSpireMod {

    public void initialize() {
        // åŸæœ‰åˆå§‹åŒ–...

        // å•æœºæ¨¡å¼åˆå§‹åŒ–
        if (SinglePlayerConfig.SINGLE_PLAYER_MODE) {
            initSinglePlayerMode();
        }
    }

    private void initSinglePlayerMode() {
        // åˆå§‹åŒ–æœ¬åœ°äº‹ä»¶å¤„ç†å™¨
        LocalEventHandler.initLocalHandlers();

        if (SinglePlayerConfig.SHOW_OPERATION_LOG) {
            System.out.println("[MOD] Single player mode initialized");
        }
    }
}
```

### 7.2 æ¸¸æˆå¼€å§‹é€‚é…

#### ä¿®æ”¹ GameManager.java
```java
public class GameManager {

    // å•æœºæ¨¡å¼å‡†å¤‡è¿›å…¥æ¸¸æˆ
    public static void prepareEnterGameSinglePlayer() {
        // åŸæœ‰å‡†å¤‡é€»è¾‘...
        setSeed();
        GlobalManager.enterLobbyFlag = true;
        CardCrawlGame.mode = CardCrawlGame.GameMode.CHAR_SELECT;
        CardCrawlGame.mainMenuScreen.fadedOut = true;

        // å•æœºæ¨¡å¼ç‰¹æ®Šå¤„ç†
        if (SinglePlayerConfig.SINGLE_PLAYER_MODE) {
            // è‡ªåŠ¨åˆå§‹åŒ–AIç©å®¶
            initAIPlayers();
        }

        // åŸæœ‰é€»è¾‘...
        AbstractDungeon.generateSeeds();
    }

    // åˆå§‹åŒ–AIç©å®¶
    private static void initAIPlayers() {
        // TODO: åˆ›å»ºå¹¶é…ç½®AIç©å®¶
        if (SinglePlayerConfig.SHOW_OPERATION_LOG) {
            System.out.println("[GAME] Initializing AI players for single player");
        }
    }
}
```

## å…«ã€ä¿®æ”¹å®æ–½æ­¥éª¤

### 8.1 ç¬¬ä¸€é˜¶æ®µï¼šç½‘ç»œå±‚æ”¹é€ ï¼ˆ1å¤©ï¼‰
- [ ] åˆ›å»º `SinglePlayerConfig.java`
- [ ] å®ç° `LocalEventBus.java`
- [ ] ä¿®æ”¹ `SocketServer.java` æ·»åŠ å¼€å…³
- [ ] ä¿®æ”¹ `Communication.java` æ·»åŠ æœ¬åœ°åˆ†æ”¯

### 8.2 ç¬¬äºŒé˜¶æ®µï¼šäº‹ä»¶ç³»ç»Ÿï¼ˆ1å¤©ï¼‰
- [ ] åˆ›å»º `LocalEventHandler.java`
- [ ] å®ç°äº‹ä»¶æ³¨å†Œå’Œå¤„ç†
- [ ] ä¿®æ”¹ `FightProtocol.java` æ·»åŠ æœ¬åœ°å¤„ç†
- [ ] æµ‹è¯•äº‹ä»¶æœ¬åœ°ä¼ é€’

### 8.3 ç¬¬ä¸‰é˜¶æ®µï¼šè‡ªåŠ¨åŒ–ç³»ç»Ÿï¼ˆ1-2å¤©ï¼‰
- [ ] åˆ›å»º `AutoPlayManager.java`
- [ ] ä¿®æ”¹ `PlayerMonster.java` æ·»åŠ è‡ªåŠ¨æ“ä½œ
- [ ] å®ç°è‡ªåŠ¨å›åˆã€å‡ºç‰Œé€»è¾‘
- [ ] æ·»åŠ äº‹ä»¶å“åº”æœºåˆ¶

### 8.4 ç¬¬å››é˜¶æ®µï¼šé›†æˆæµ‹è¯•ï¼ˆ1å¤©ï¼‰
- [ ] ä¿®æ”¹æ¸¸æˆåˆå§‹åŒ–é€»è¾‘
- [ ] å®Œæ•´åŠŸèƒ½æµ‹è¯•
- [ ] ä¿®å¤å‘ç°çš„é—®é¢˜
- [ ] æ€§èƒ½ä¼˜åŒ–

## ä¹ã€å…³é”®ä¿®æ”¹ç‚¹

### 9.1 æ–°å¢æ–‡ä»¶åˆ—è¡¨
```
src/main/java/pvp_in_the_spire/
â”œâ”€â”€ config/
â”‚   â””â”€â”€ SinglePlayerConfig.java          # å•æœºæ¨¡å¼é…ç½®
â”œâ”€â”€ network/
â”‚   â””â”€â”€ LocalEventBus.java               # æœ¬åœ°äº‹ä»¶æ€»çº¿
â”œâ”€â”€ battle/
â”‚   â””â”€â”€ AutoPlayManager.java             # è‡ªåŠ¨æ“ä½œç®¡ç†å™¨
â””â”€â”€ network/
    â””â”€â”€ LocalEventHandler.java           # æœ¬åœ°äº‹ä»¶å¤„ç†
```

### 9.2 ä¿®æ”¹æ–‡ä»¶åˆ—è¡¨
```
src/main/java/pvp_in_the_spire/
â”œâ”€â”€ SocketServer.java                    # æ·»åŠ å•æœºæ¨¡å¼å¼€å…³
â”œâ”€â”€ Communication.java                   # æ·»åŠ æœ¬åœ°äº‹ä»¶åˆ†æ”¯
â”œâ”€â”€ FightProtocol.java                   # æ·»åŠ æœ¬åœ°æ¶ˆæ¯å¤„ç†
â”œâ”€â”€ PlayerMonster.java                   # æ·»åŠ è‡ªåŠ¨æ“ä½œæ”¯æŒ
â””â”€â”€ GameManager.java                     # æ·»åŠ å•æœºåˆå§‹åŒ–
```

### 9.3 æ ¸å¿ƒä»£ç ä¿®æ”¹ç‚¹

1. **å…¨å±€é…ç½®** (`SocketServer.java`)
```java
// ç¬¬10è¡Œ
public static boolean SINGLE_PLAYER_MODE = true;
```

2. **äº‹ä»¶æ€»çº¿** (`LocalEventBus.java`)
```java
// æ ¸å¿ƒæ–¹æ³•
public <T> void sendEvent(T event) {
    processEvent(event);  // åŒæ­¥å¤„ç†
}
```

3. **è‡ªåŠ¨ç®¡ç†å™¨** (`AutoPlayManager.java`)
```java
// è‡ªåŠ¨å›åˆ
public void executeTurn() {
    new Thread(() -> {
        // å›åˆå¼€å§‹
        onTurnStart();
        // è‡ªåŠ¨å‡ºç‰Œ
        playCardsInTurn();
        // å›åˆç»“æŸ
        onTurnEnd();
    }).start();
}
```

4. **PlayerMonsterè‡ªåŠ¨åŒ–** (`PlayerMonster.java`)
```java
// è‡ªåŠ¨å›åˆæ‰§è¡Œ
@Override
public void takeTurn() {
    if (this.isAutoPlay && this.autoPlayManager != null) {
        new Thread(() -> {
            Thread.sleep(800);
            this.autoPlayManager.executeTurn();
        }).start();
    }
}
```

## åã€æµ‹è¯•éªŒè¯

### 10.1 æµ‹è¯•æ£€æŸ¥ç‚¹
- [ ] æ•Œæ–¹ç©å®¶è‡ªåŠ¨æ‰§è¡Œå›åˆ
- [ ] å¡ç‰Œæ­£ç¡®æ˜¾ç¤ºå’Œæ›´æ–°
- [ ] èƒ½é‡å’Œæ‰‹ç‰ŒåŒæ­¥æ­£ç¡®
- [ ] Buffå’Œæ•ˆæœæ­£ç¡®åº”ç”¨
- [ ] å›åˆæµç¨‹é¡ºç•…æ— å¡é¡¿

### 10.2 æ—¥å¿—éªŒè¯
å¼€å¯ `SinglePlayerConfig.SHOW_OPERATION_LOG = true` åï¼Œåº”è¯¥çœ‹åˆ°ï¼š
```
[AUTO] Turn 1 started
[AUTO] Drawing 5 cards
[AUTO] Hand updated: 5 cards
[AUTO] Playing card: Strike (Cost: 1)
[AUTO] Energy updated: 2
[AUTO] Turn ended
```

## åä¸€ã€æ½œåœ¨é—®é¢˜å’Œè§£å†³

### 11.1 å¡ç‰Œæ•ˆæœåŒæ­¥
**é—®é¢˜**ï¼šè‡ªåŠ¨å‡ºç‰Œåæ•ˆæœå¯èƒ½ä¸åŒæ­¥
**è§£å†³**ï¼šå¼ºåˆ¶åŒæ­¥æ‰€æœ‰æ¸¸æˆçŠ¶æ€
```java
// åœ¨AutoPlayManager.javaä¸­æ·»åŠ 
private void syncGameState() {
    AbstractDungeon.actionManager.update();  // å¼ºåˆ¶æ›´æ–°Actioné˜Ÿåˆ—
    AbstractDungeon.actionManager.nextPreBattleAction();  // å¤„ç†å¾…å¤„ç†Action
}
```

### 11.2 æ— é™å¾ªç¯é˜²æŠ¤
**é—®é¢˜**ï¼šè‡ªåŠ¨å‡ºç‰Œå¯èƒ½é™·å…¥æ— é™å¾ªç¯
**è§£å†³**ï¼šæ·»åŠ å®‰å…¨è®¡æ•°å™¨
```java
// åœ¨playCardsInTurn()ä¸­æ·»åŠ 
int safetyCounter = 0;
while (currentEnergy > 0 && safetyCounter < 20) {
    safetyCounter++;
    // å‡ºç‰Œé€»è¾‘...
}
```

## åäºŒã€æ‰©å±•å»ºè®®

### 12.1 é…ç½®é€‰é¡¹æ‰©å±•
- æ·»åŠ è‡ªåŠ¨å‡ºç‰Œç­–ç•¥é€‰æ‹©ï¼ˆéšæœºã€ä¼˜å…ˆæ”»å‡»ç­‰ï¼‰
- æ·»åŠ æ“ä½œé€Ÿåº¦è°ƒèŠ‚
- æ·»åŠ è·³è¿‡ç‰¹å®šåŠ¨ç”»çš„é€‰é¡¹

### 12.2 è°ƒè¯•åŠŸèƒ½
- æ·»åŠ æ“ä½œæ—¥å¿—è¯¦ç»†çº§åˆ«
- æ·»åŠ å•æ­¥æ‰§è¡Œæ¨¡å¼
- æ·»åŠ çŠ¶æ€æŸ¥çœ‹å™¨

## åä¸‰ã€æ€»ç»“

è¿™ä¸ªæ ¸å¿ƒä¿®æ”¹æ–¹æ¡ˆä¸“æ³¨äºï¼š

### âœ… ä¸»è¦ç‰¹æ€§
1. **å®Œæ•´ä¿ç•™æ¸²æŸ“ç³»ç»Ÿ**ï¼šæ•Œæ–¹ç©å®¶æ‰€æœ‰ä¿¡æ¯æ­£ç¡®æ˜¾ç¤º
2. **æœ¬åœ°äº‹ä»¶æ›¿ä»£ç½‘ç»œ**ï¼šæµç•…çš„æœ¬åœ°é€šä¿¡
3. **è‡ªåŠ¨æ“ä½œæµç¨‹**ï¼šå®Œæ•´çš„è‡ªåŠ¨å›åˆæ‰§è¡Œ
4. **äº‹ä»¶é©±åŠ¨æ¶æ„**ï¼šæ˜“äºæ‰©å±•å’Œç»´æŠ¤

### ğŸ¯ é¢„æœŸæ•ˆæœ
- æ•Œæ–¹ç©å®¶å®Œå…¨è‡ªåŠ¨åŒ–æ“ä½œ
- ä¿ç•™å®Œæ•´çš„æˆ˜æ–—å’Œæ˜¾ç¤ºé€»è¾‘
- æµç•…çš„å•æœºæ¸¸æˆä½“éªŒ
- æ˜“äºè°ƒè¯•å’Œæ‰©å±•

é€šè¿‡è¿™ä¸ªæ–¹æ¡ˆï¼Œç”¨æˆ·å¯ä»¥å®Œå…¨æ§åˆ¶AIè¡Œä¸ºï¼ˆé€šè¿‡ä¿®æ”¹AutoPlayManagerçš„ç­–ç•¥ï¼‰ï¼ŒåŒæ—¶äº«å—è‡ªåŠ¨åŒ–çš„æˆ˜æ–—æµç¨‹ã€‚ç³»ç»Ÿä¿ç•™äº†æ‰€æœ‰åŸæœ‰çš„æ¸²æŸ“å’Œé€»è¾‘ï¼Œåªå°†ç½‘ç»œé€šä¿¡æ›¿æ¢ä¸ºæœ¬åœ°äº‹ä»¶ï¼Œå®ç°çœŸæ­£çš„å•æœºæ¸¸æˆä½“éªŒã€‚