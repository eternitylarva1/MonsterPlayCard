# PVP in the Spire - 敌方玩家系统架构分析

## 概述

本文档详细分析了PVP in the Spire模组中敌方玩家的渲染、动作执行、出牌机制和效果同步系统。该系统通过补丁机制和网络通信，实现了在单机游戏框架下的多人PVP对战。

## 一、渲染系统

### 1.1 核心渲染类

#### PlayerMonster.java (敌方玩家主体类)
- **位置**: `src/main/java/pvp_in_the_spire/character/PlayerMonster.java:36`
- **继承**: `AbstractMonster`
- **职责**: 敌方玩家的主体渲染和状态管理

**关键字段**:
```java
// 渲染组件
public AbstractPlayer renderPlayer;              // 实际渲染的角色模型
public BattleCardPanel battleCardPanel;          // 战斗信息面板
public OrbManager orbManager;                    // 充能球管理器
public AbstractStance stance;                    // 姿态系统

// 状态标记
public boolean renderCardFlag = false;           // 是否渲染手牌
public boolean pauseFlag;                        // 是否负责阻塞操作
public int playerTag;                            // 玩家标签
public int idTurn;                               // 回合计数
```

**渲染流程** (`PlayerMonster.java:199-218`):
```java
public void render(SpriteBatch sb) {
    // 1. 渲染战斗信息面板（卡牌、能量、遗物、药水）
    if(this.renderCardFlag) {
        this.battleCardPanel.render(sb);
    }
    // 2. 渲染基础怪物（血条等）
    super.render(sb);
    // 3. 渲染角色立绘
    if(this.renderPlayer != null) {
        if(this.isDead)
            this.renderPlayer.render(sb);
        else
            this.renderPlayer.renderPlayerImage(sb);
    }
    // 4. 渲染充能球
    this.orbManager.render(sb);
    // 5. 渲染姿态
    this.stance.render(sb);
}
```

#### PlayerForShow.java (角色展示类)
- **位置**: `src/main/java/pvp_in_the_spire/character/PlayerForShow.java:18`
- **继承**: `CustomPlayer`
- **职责**: 提供角色动画和立绘渲染

**初始化动画** (`PlayerForShow.java:26-29`):
```java
public void loadTexture(String atlasUrl, String skeletonUrl, float scale) {
    this.loadAnimation(atlasUrl, skeletonUrl, scale);
}
```

### 1.2 UI面板系统

#### BattleCardPanel.java (战斗信息面板)
- **位置**: `src/main/java/pvp_in_the_spire/ui/BattleUI/BattleCardPanel.java:13`
- **职责**: 组合显示所有敌方战斗信息

**组件构成**:
```java
public CardBox cardBox;              // 显示手牌
public MonsterEnergyPanel energyPanel;  // 显示能量
public MonsterRelicPanel monsterRelicPanel;  // 显示遗物
public MonsterPotionPanel potionPanel;  // 显示药水
```

#### CardBox.java (手牌显示框)
- **位置**: `src/main/java/pvp_in_the_spire/patches/CardShowPatch/CardBox.java:9`
- **职责**: 显示敌方手牌、计算攻击意图

**关键方法**:

位置计算 (`CardBox.java:49-56`):
```java
int getXOffsetById(int idCard) {
    int maxSet = (int)(xCenter / (AbstractCard.IMG_WIDTH * SHOW_SCALE)) - 1;
    if(maxSet > idCard)
        return -idCard;
    return -maxSet;
}
```

攻击意图计算 (`CardBox.java:83-100`):
```java
public AbstractMonster.Intent getIntent() {
    if(shownCards.drawingCards.isEmpty())
        return AbstractMonster.Intent.UNKNOWN;

    // 统计接下来5张牌的总伤害
    this.damageAmount = sumDamageAmount(5);
    if(damageAmount > 0)
        return AbstractMonster.Intent.ATTACK;

    AbstractCard firstCard = shownCards.drawingCards.get(0);
    if(firstCard.type == AbstractCard.CardType.POWER)
        return AbstractMonster.Intent.BUFF;

    if(firstCard.target == AbstractCard.CardTarget.SELF) {
        if(firstCard.baseBlock > 0)
            return AbstractMonster.Intent.DEFEND;
    }
    return AbstractMonster.Intent.ATTACK;
}
```

伤害统计 (`CardBox.java:58-80`):
```java
public int sumDamageAmount(int cardNum) {
    if(cardNum > shownCards.drawingCards.size())
        cardNum = shownCards.drawingCards.size();

    int sumDamage = 0;
    for(int idCard = 0; idCard < cardNum; ++idCard) {
        AbstractCard card = shownCards.drawingCards.get(idCard);
        if(card.type == AbstractCard.CardType.ATTACK) {
            sumDamage += card.baseDamage;
        }
    }
    return sumDamage;
}
```

## 二、动作执行系统

### 2.1 PlayerMonster动作处理

#### 回合管理
**回合开始** (`PlayerMonster.java:439-442`):
```java
@Override
public void applyStartOfTurnPowers() {
    super.applyStartOfTurnPowers();
    this.endTurnFlag = false;
}
```

**回合执行** (`PlayerMonster.java:181-191`):
```java
@Override
public void takeTurn() {
    if(this.pauseFlag) {
        System.out.printf("%d take turn\n", playerTag);
        AbstractDungeon.actionManager.addToBottom(
            new MultiPauseAction()
        );
    }
}
```

**回合结束** (`PlayerMonster.java:405-420`):
```java
public void endOfTurnTrigger() {
    System.out.printf("%d end turn\n", this.playerTag);
    ++idTurn;
    this.endTurnFlag = true;

    for(AbstractPower eachPower : powers) {
        eachPower.atEndOfTurnPreEndTurnCards(false);
    }
    for(AbstractPower eachPower : powers) {
        eachPower.atEndOfTurn(false);
    }
}
```

#### 伤害处理
**伤害执行** (`PlayerMonster.java:317-396`):
```java
@Override
public void damage(DamageInfo info) {
    // 允许打破护甲
    this.allowLoseBlock = true;

    // 如果对面已经逃跑，不再受到任何伤害
    if(ActionNetworkPatches.disableCombatTrigger) {
        return;
    }

    // 处理姿态伤害修正
    if(!isReceiveDamage())
        info.output = (int)this.stance.atDamageReceive(info.output, info.type);

    // 处理伤害计算
    int damageAmount = info.output;
    if (!this.isDying && !this.isEscaping) {
        if (damageAmount < 0) {
            damageAmount = 0;
        }

        boolean hadBlock = true;
        if (this.currentBlock == 0) {
            hadBlock = false;
        }

        boolean weakenedToZero = damageAmount == 0;
        damageAmount = this.decrementBlock(info, damageAmount);
        damageAmount = changeDamageInfo(info, damageAmount);

        this.lastDamageTaken = Math.min(damageAmount, this.currentHealth);
        boolean probablyInstantKill = this.currentHealth == 0;

        if (damageAmount > 0) {
            // 伤害逻辑
            this.currentHealth -= damageAmount;
            if (this.currentHealth < 0) {
                this.currentHealth = 0;
            }
            this.healthBarUpdatedEvent();
        }

        if (this.currentHealth <= 0) {
            this.currentHealth = 0;
            makeItDie();
        }
    }

    this.allowLoseBlock = false;
    // 发送伤害事件给对端
    ActionNetworkPatches.onAttackSend(info, this);
}
```

### 2.2 网络动作转换 - ActionNetworkPatches

#### 核心转换机制
**对象身份转换** (`ActionNetworkPatches.java:124-167`):

编码端:
```java
public static void creatureEncode(DataOutputStream streanHandle,
      AbstractCreature creature, boolean invert) {
    if(creature == null || creature.isPlayer) {
        streanHandle.writeInt(GlobalManager.myPlayerTag);
    } else {
        PlayerMonster playerMonster = (PlayerMonster) creature;
        streanHandle.writeInt(playerMonster.playerTag);
    }
}
```

解码端:
```java
public static AbstractCreature creatureDecode(DataInputStream streanHandle, boolean invert) {
    int playerTag = streanHandle.readInt();
    if(playerTag == GlobalManager.myPlayerTag)
        return AbstractDungeon.player;

    PlayerInfo info = GlobalManager.playerManager.getPlayerInfo(playerTag);
    return info.playerMonster;
}
```

#### 伤害Action转换
**发送端** (`ActionNetworkPatches.java:221-236`):
```java
@SpirePatch(clz = AbstractPlayer.class, method = "damage")
public static class PlayerDamageSendPatch {
    @SpirePostfixPatch
    public static void fix(AbstractPlayer __instance, DamageInfo info) {
        if(stopSendAttack) {
            return;
        }
        onAttackSend(info, __instance);
    }
}

public static void onAttackSend(DamageInfo info, AbstractCreature target) {
    AutomaticSocketServer server = AutomaticSocketServer.getServer();
    server.streamHandle.writeInt(FightProtocol.DAMAGE_CODE_0812);
    damageInfoEncode(server.streamHandle, info);
    creatureEncode(server.streamHandle, target, true);
    server.send();
}
```

**接收端** (`ActionNetworkPatches.java:199-218`):
```java
public static void onAttackReceive(DataInputStream streamHandle) {
    DamageInfo info = damageInfoDecode(streamHandle);
    AbstractCreature target = creatureDecode(streamHandle, false);

    if(info == null || target == null) {
        System.out.println("Receive damage failed");
        return;
    }

    stopSendAttack = true;
    if(!disableCombatTrigger)
        target.damage(info);
    stopSendAttack = false;
}
```

#### Buff/Power转换
**发送端** (`ActionNetworkPatches.java:925-991`):
```java
@SpirePatch(clz = ApplyPowerAction.class, method = SpirePatch.CONSTRUCTOR,
        paramtypez = {AbstractCreature.class, AbstractCreature.class,
                AbstractPower.class, int.class, boolean.class, AbstractGameAction.AttackEffect.class})
public static class BuffInfoSend {
    @SpirePostfixPatch
    public static void postFix(ApplyPowerAction __instance,
                               AbstractCreature target, AbstractCreature source,
                               AbstractPower powerToApply, int stackAmount, boolean isFast,
                               AbstractGameAction.AttackEffect effect) {
        if(!SocketServer.USE_NETWORK || stopTrigger)
            return;

        PowerMapping.initCreatorMapper();
        AutomaticSocketServer server = AutomaticSocketServer.getServer();

        if(!(powerToApply instanceof TheBombPower) &&
            !PowerMapping.creatorMapper.containsKey(powerToApply.ID)) {
            // 强制编码未映射的Power
            forceEncodePower(server.streamHandle, powerToApply,
                __instance.amount, __instance.target,
                __instance.source, __instance.attackEffect);
        } else {
            // 标准编码已映射的Power
            applyPowerEncode(server.streamHandle, __instance, powerToApply);
        }
        server.send();
    }
}
```

**接收端** (`ActionNetworkPatches.java:717-754`):
```java
public static void applyPowerDecode(DataInputStream streamHandle) {
    AbstractPower power = powerDecode(streamHandle);
    AbstractCreature target = creatureDecode(streamHandle, false);
    AbstractCreature source = creatureDecode(streamHandle, false);

    try {
        String buffEffect = streamHandle.readUTF();
        if(power == null || target == null || source == null)
            return;

        BuffInfoSend.stopTrigger = true;
        AbstractDungeon.actionManager.addToBottom(
            new ApplyPowerAction(
                target, source, power, power.amount, false,
                AbstractGameAction.AttackEffect.valueOf(buffEffect)
            )
        );
        BuffInfoSend.stopTrigger = false;
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

## 三、出牌系统

### 3.1 卡牌标识系统

#### UseCardSend.java (卡牌传输管理)
- **位置**: `src/main/java/pvp_in_the_spire/patches/CardShowPatch/UseCardSend.java:25`
- **职责**: 管理卡牌ID映射和传输

**哈希映射管理**:
```java
public static HashMap<AbstractCard, Integer> playerCardMap =
        new HashMap<AbstractCard, Integer>();        // 本地卡牌 → ID映射
public static HashMap<Integer, AbstractCard> monsterCardMap =
        new HashMap<Integer, AbstractCard>();         // 敌方卡牌ID → 卡牌实例映射
```

**卡牌通信ID获取** (`UseCardSend.java:131-147`):
```java
public static int getCardCommunicationID(AbstractCard card) {
    if(!playerCardMap.containsKey(card)) {
        int newCode = playerCardMap.size();
        playerCardMap.put(card, newCode);
        // 首次传输，发送完整卡牌信息
        Communication.sendEvent(new CardInfoEvent(card, newCode));
        return newCode;
    }
    // 后续传输，只使用ID
    return playerCardMap.get(card);
}
```

### 3.2 出牌事件捕获

#### 出牌补丁 (`UseCardSend.java:287-299`)
```java
@SpirePatch(clz = AbstractPlayer.class, method = "useCard")
public static class SendUseCardAction {
    @SpirePostfixPatch
    public static void fix(AbstractPlayer __instance,
           AbstractCard c, AbstractMonster monster, int energyOnUse) {
        if(!SocketServer.USE_NETWORK) {
            return;
        }
        // 发送使用卡牌事件
        int cardCode = getCardCommunicationID(c);
        Communication.sendEvent(new UseCardEvent(cardCode));
        updateUseTime(c);
    }
}
```

### 3.3 卡牌信息传输

#### CardInfoEvent.java (卡牌信息事件)
- **位置**: `src/main/java/pvp_in_the_spire/events/CardInfoEvent.java:16`
- **职责**: 传输卡牌基本定义

**编码** (`CardInfoEvent.java:29-46`):
```java
@Override
public void encode(DataOutputStream streamHandle) {
    try {
        // 发送玩家标签
        GlobalManager.playerManager.encodePlayer(streamHandle);
        // 发送卡牌ID
        streamHandle.writeUTF(card.cardID);
        // 发送升级次数
        streamHandle.writeInt(card.timesUpgraded);
        // 发送卡牌编码
        streamHandle.writeInt(idCard);
        // 发送基础魔法数值（兼容灭除之刃）
        streamHandle.writeInt(card.baseMagicNumber);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

**解码** (`CardInfoEvent.java:49-90`):
```java
@Override
public void decode(DataInputStream streamHandle) {
    try {
        // 解码玩家信息
        PlayerInfo info = GlobalManager.playerManager.decodePlayerInfo(streamHandle);
        if(info == null)
            return;

        // 接收卡牌名称
        String cardName = streamHandle.readUTF();
        int upgradeNum = streamHandle.readInt();
        int cardHashCode = streamHandle.readInt();
        int magicNumber = streamHandle.readInt();

        // 查找卡牌库
        if(!CardLibrary.cards.containsKey(cardName)) {
            System.out.print("unknown card: ");
            System.out.println(cardName);
            return;
        }

        // 复制卡牌实例
        AbstractCard card = CardLibrary.cards.get(cardName).makeCopy();

        // 特殊处理灭除之刃
        if(card instanceof Expunger) {
            ((Expunger) card).setX(magicNumber);
        }

        // 应用升级
        for(int idUp = 0; idUp < upgradeNum; ++idUp) {
            card.upgrade();
        }

        // 记录到映射表
        info.cardManager.addCard(cardHashCode, card);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

### 3.4 手牌同步

#### HandCardSend.java (手牌同步)
- **位置**: `src/main/java/pvp_in_the_spire/patches/CardShowPatch/HandCardSend.java:20`
- **职责**: 同步手牌列表变化

**手牌刷新监听** (`HandCardSend.java:78-108`):
```java
@SpirePatch(clz = CardGroup.class, method = "refreshHandLayout")
public static class HandCardRefreshEvent {
    @SpirePrefixPatch
    public static void fix(CardGroup __instance) {
        // 我方已死亡，不需同步
        if(!SocketServer.USE_NETWORK ||
            GlobalManager.getBattleInfo().selfDeadFlag) {
            return;
        }

        // 遍历手牌生成ID列表
        ArrayList<Integer> cardIdList = new ArrayList<Integer>();
        Iterator cardIter = __instance.group.iterator();
        while (cardIter.hasNext()) {
            AbstractCard tempCard = (AbstractCard) cardIter.next();
            int tempCode = UseCardSend.getCardCommunicationID(tempCard);
            cardIdList.add(tempCode);
        }

        // 发送手牌更新事件
        Communication.sendEvent(new UpdateHandCardEvent(cardIdList));
        // 更新即将抽到的牌
        DrawPileSender.updateDrawingCards();
    }
}
```

**解码接收** (`HandCardSend.java:26-52`):
```java
public static void handCardDecode(DataInputStream streamHandle) {
    monsterCardList.cardList.clear();
    try {
        int cardNum = streamHandle.readInt();
        for(int idCard = 0; idCard < cardNum; ++idCard) {
            int tempCode = streamHandle.readInt();
            if(UseCardSend.monsterCardMap.containsKey(tempCode)) {
                AbstractCard tempCard = UseCardSend.monsterCardMap.get(tempCode);
                monsterCardList.cardList.add(tempCard);
            }
        }
        monsterCardList.justUpdateFlag = true;
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

### 3.5 抽牌堆预览

#### DrawPileSender.java (抽牌堆同步)
- **位置**: `src/main/java/pvp_in_the_spire/patches/CardShowPatch/DrawPileSender.java:15`
- **职责**: 同步即将抽到的牌（显示接下来5张）

**更新抽牌堆** (`DrawPileSender.java:109-129`):
```java
public static void updateDrawingCards() {
    ArrayList<AbstractCard> cardGroup = AbstractDungeon.player.drawPile.group;
    if(!compareCardRecord(cardGroup, drawingCards)) {
        recordCards(cardGroup);

        ArrayList<Integer> cardIdList = new ArrayList<>();
        for(AbstractCard eachCard : drawingCards) {
            int tempCode = UseCardSend.getCardCommunicationID(eachCard);
            // 叠加升级过的字符位
            tempCode += eachCard.timesUpgraded * UPGRADE_LEVEL;
            cardIdList.add(tempCode);
        }
        Communication.sendEvent(new DrawCardUpdateEvent(cardIdList));
    }
}
```

**解码接收** (`DrawPileSender.java:73-107`):
```java
public static void drawCardDecode(DataInputStream streamHandle) {
    CardRecorder recorder = HandCardSend.monsterCardList;
    recorder.justUpdateFlag = true;
    recorder.drawingCards.clear();

    try {
        int cardNum = streamHandle.readInt();
        for(int idCard = 0; idCard < cardNum; ++idCard) {
            int tempId = streamHandle.readInt();
            // 解码升级次数
            int upgradeTime = tempId / UPGRADE_LEVEL;
            tempId = tempId % UPGRADE_LEVEL;

            if(UseCardSend.monsterCardMap.containsKey(tempId)) {
                AbstractCard tempCard = UseCardSend.monsterCardMap.get(tempId);
                // 补充缺少的升级次数
                upgradeTime -= tempCard.timesUpgraded;
                for(int i = 0; i < upgradeTime; ++i)
                    tempCard.upgrade();

                recorder.drawingCards.add(tempCard);
            }
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

## 四、出牌效果执行

### 4.1 卡牌显示

#### UseCardSend.java (敌方卡牌显示)
**解码卡牌使用** (`UseCardSend.java:167-195`):
```java
public static void useCardDecode(DataInputStream streamHandle) {
    try {
        int cardCode = streamHandle.readInt();
        if(monsterCardMap.containsKey(cardCode)) {
            AbstractCard card = monsterCardMap.get(cardCode);
            card.unfadeOut();
            // 添加卡牌短暂显示特效
            AbstractDungeon.effectList.add(new ShowCardBrieflyEffect(card));
        } else {
            System.out.println("cannot find card code");
            System.out.println(cardCode);
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

### 4.2 卡牌效果处理

#### PlayerCardManager.java (卡牌管理器)
- **位置**: `src/main/java/pvp_in_the_spire/player_management/PlayerCardManager.java:14`
- **职责**: 管理卡牌实例和ID转换

**卡牌ID转换** (`PlayerCardManager.java:35-50`):
```java
public AbstractCard getCard(int idCard) {
    // 解码升级次数
    int upgradeTime = idCard / DrawPileSender.UPGRADE_LEVEL;
    idCard = idCard % DrawPileSender.UPGRADE_LEVEL;

    if(cardMap.containsKey(idCard)) {
        AbstractCard tempCard = cardMap.get(idCard);
        // 判断是否需要补充升级次数
        upgradeTime -= tempCard.timesUpgraded;
        for(int idUp = 0; idUp < upgradeTime; ++idUp)
            tempCard.upgrade();
        return tempCard;
    }
    return null;
}
```

**ID列表转卡牌列表** (`PlayerCardManager.java:64-76`):
```java
public void convertToCardList(ArrayList<Integer> idList,
                              ArrayList<AbstractCard> cardList) {
    cardList.clear();
    for(int eachId : idList) {
        AbstractCard tempCard = getCard(eachId);
        if(tempCard != null)
            cardList.add(tempCard);
    }
}
```

#### CardRecorder.java (卡牌记录器)
- **位置**: `src/main/java/pvp_in_the_spire/patches/CardShowPatch/CardRecorder.java:8`
- **职责**: 记录当前显示的卡牌列表

```java
public class CardRecorder {
    public ArrayList<AbstractCard> cardList = new ArrayList<AbstractCard>();  // 当前手牌
    public ArrayList<AbstractCard> drawingCards = new ArrayList<>();          // 即将抽到的牌
    public boolean justUpdateFlag = false;                                     // 是否刚刚更新过
}
```

### 4.3 网络事件系统

#### Communication.java (事件通信)
- **位置**: `src/main/java/pvp_in_the_spire/pvp_api/Communication.java:14`
- **职责**: 事件注册和发送

**事件注册** (`Communication.java:17-30`):
```java
public static boolean registerEvent(BaseEvent event) {
    HashMap<String, BaseEvent> eventMap = GlobalManager.eventMap;
    ArrayList<BaseEvent> eventList = GlobalManager.eventList;

    if(eventMap.containsKey(event.eventId))
        return false;

    eventMap.put(event.eventId, event);
    event.listId = eventList.size();
    eventList.add(event);
    return true;
}
```

**发送事件** (`Communication.java:33-65`):
```java
public static void advanceSendEvent(BaseEvent event, int playerTag) {
    if(AutomaticSocketServer.globalServer == null)
        return;

    HashMap<String, BaseEvent> eventMap = GlobalManager.eventMap;
    if(!eventMap.containsKey(event.eventId)) {
        System.out.printf("Unknown event: %s\n", event.eventId);
        return;
    }

    AutomaticSocketServer server = AutomaticSocketServer.getServer();
    DataOutputStream stream = server.streamHandle;

    try {
        stream.writeInt(FightProtocol.CUSTOM_EVENT);
        stream.writeInt(eventMap.get(event.eventId).listId);
        event.encode(stream);

        if(playerTag == -1)
            server.send();
        else
            server.targetSend(playerTag);
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

### 4.4 战斗协议处理

#### FightProtocol.java (战斗协议)
- **位置**: `src/main/java/pvp_in_the_spire/actions/FightProtocol.java:24`
- **职责**: 处理所有战斗相关网络消息

**消息读取** (`FightProtocol.java:164-355`):
```java
public boolean readData(DataInputStream stream) {
    try {
        int tempData = stream.readInt();

        switch (tempData) {
            case DAMAGE_CODE_0812:
                ActionNetworkPatches.onAttackReceive(stream);
                break;
            case USE_CARD:
                UseCardSend.useCardDecode(stream);
                break;
            case UPDATE_HAND_CARD:
                HandCardSend.handCardDecode(stream);
                break;
            case DRAWING_CARD_UPDATE:
                DrawPileSender.drawCardDecode(stream);
                break;
            case ENERGY_UPDATE:
                ControlMoster.energyChangeDecode(stream);
                break;
            case APPLY_POWER:
                ActionNetworkPatches.applyPowerDecode(stream);
                break;
            case REMOVE_POWER:
                ActionNetworkPatches.removePowerDecode(stream);
                break;
            case CUSTOM_EVENT:
                handleCustomEvent(stream);
                break;
            case FORCE_SEND_POWER:
                ActionNetworkPatches.forceDecodePower(stream);
                break;
            // ... 其他case
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
    return false;
}
```

## 五、核心类关系图

```
┌─────────────────────┐
│   AbstractPlayer    │ ◄── 本地玩家
└──────────┬──────────┘
           │
           │ 继承
           ▼
┌─────────────────────┐
│   PlayerMonster     │ ◄── 敌方玩家主体
│  - renderPlayer     │
│  - battleCardPanel  │
│  - orbManager       │
│  - stance           │
└──────────┬──────────┘
           │
           ├──┬────────┬────────┬────────┐
           ▼  ▼        ▼        ▼        ▼
    ┌────────┐┌─────┐┌────────┐┌──────┐┌───────┐
    │ CardBox││Energy││ Relic  ││Potion││ Orb   │
    │        ││Panel ││ Panel  ││Panel ││Manager│
    └────────┘└─────┘└────────┘└──────┘└───────┘
           │
           ▼
┌─────────────────────┐      ┌──────────────────────┐
│ CardRecorder        │      │  PlayerCardManager   │
│ - cardList          │      │  - cardMap           │
│ - drawingCards      │      │  - cardRecorder      │
└─────────────────────┘      └──────────────────────┘
           │                          │
           │ 记录                      │ 管理
           ▼                          ▼
┌─────────────────────┐      ┌──────────────────────┐
│   UseCardSend       │      │   ActionNetworkPatches│
│ - playerCardMap     │      │  - 编码/解码方法     │
│ - monsterCardMap    │      │  - 补丁拦截          │
└─────────────────────┘      └──────────────────────┘
           │                          │
           │ 传输                      │ 转换
           ▼                          ▼
┌─────────────────────┐      ┌──────────────────────┐
│   CardInfoEvent     │      │   FightProtocol      │
│   UseCardEvent      │      │  - 消息处理          │
│   UpdateHandCard... │      │  - 协议定义          │
└─────────────────────┘      └──────────────────────┘
           │
           │ 事件
           ▼
┌─────────────────────┐
│   Communication     │
│  - registerEvent    │
│  - sendEvent        │
└─────────────────────┘
           │
           │ 发送
           ▼
┌─────────────────────┐
│ AutomaticSocketServer│
│  - 全局服务器实例    │
└─────────────────────┘
```

## 六、关键设计模式

### 1. 补丁拦截模式
使用ModTheSpire的 `@SpirePatch` 注解拦截游戏原版方法：
- **出牌拦截**: `AbstractPlayer.useCard`
- **伤害拦截**: `AbstractPlayer.damage`, `AbstractCreature.damage`
- **Buff拦截**: `ApplyPowerAction` 构造函数
- **手牌刷新拦截**: `CardGroup.refreshHandLayout`

### 2. 停止触发标志位
防止循环发送的核心机制：
```java
public static boolean stopSendAttack = false;      // 伤害发送
public static boolean stopSendBlockGain = false;   // 格挡发送
public static boolean stopTrigger = false;         // 通用停止
```

### 3. ID映射系统
避免重复传输卡牌定义：
- 首次传输：发送完整卡牌信息（卡牌ID、升级次数等）
- 后续传输：只发送映射ID
- 升级次数编码：通过乘法叠加到ID中

### 4. 对象身份转换
通过玩家标签而非对象引用传输：
- 发送端：将 `AbstractCreature` 转换为 `playerTag`
- 接收端：根据 `playerTag` 查找本地对象
- 优点：避免序列化复杂对象，保持引用一致性

### 5. 事件驱动架构
- **事件注册**: `Communication.registerEvent`
- **事件编码**: `BaseEvent.encode`
- **事件解码**: `BaseEvent.decode`
- **事件发送**: `Communication.sendEvent`
- **协议处理**: `FightProtocol.readData`

## 七、总结

敌方玩家系统通过巧妙的补丁机制和事件驱动架构，实现了：

1. **完整渲染**: 角色立绘、血条、手牌、能量、遗物、药水、充能球、姿态
2. **动作同步**: 伤害、Buff、格挡、治疗、姿态变化等所有战斗动作
3. **出牌可视化**: 实时显示敌方手牌、抽牌堆、使用的卡牌
4. **效果执行**: 卡牌效果自动在本地执行，保持游戏逻辑同步

该系统的核心创新在于：
- 将网络数据转换为本地Action，保持游戏引擎完整性
- 使用补丁拦截而非修改游戏源码，保证兼容性
- 通过ID映射减少网络传输量
- 事件驱动架构保证代码可扩展性

这种设计使得PVP对战体验接近本地游戏，同时保持了良好的网络效率和代码可维护性。